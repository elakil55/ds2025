# -*- coding: utf-8 -*-
"""E-commerce Sales Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zJ_X2Se-ntJLnJRvxJDK2J_FGhPmMhQo

## Introduction
# üìå E-Commerce Sales Prediction ‚Äî Machine Learning Project

## üéØ Objectif du projet
L‚Äôobjectif de ce projet est de pr√©dire le montant des ventes r√©alis√©es par un site e-commerce √† partir de diff√©rentes caract√©ristiques (prix, cat√©gorie, rating, r√©duction‚Ä¶).

Ce travail s'inscrit dans le cadre du module *Data Science & Machine Learning* et suit les √©tapes compl√®tes d‚Äôun projet de ML :
- Analyse du dataset
- Nettoyage & pr√©paration
- Exploration des donn√©es (EDA)
- Feature Engineering
- Mod√©lisation et √©valuation
- Interpr√©tation finale

## üîç Probl√©matique
La variable √† pr√©dire est **Sales**, une variable num√©rique continue.

‚û°Ô∏è Il s‚Äôagit donc d‚Äôun **probl√®me de r√©gression supervis√©e**.

## Importation des librairies
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

import kagglehub
from kagglehub import KaggleDatasetAdapter

from sklearn.model_selection import train_test_split, GridSearchCV, cross_val_score
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline

from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from xgboost import XGBRegressor

from sklearn.metrics import mean_squared_error, r2_score

sns.set(style="whitegrid")

"""## Chargement du dataset"""

file_path = "Ecommerce_Sales_Prediction_Dataset.csv"

df = pd.read_csv(file_path)

df.head()

from google.colab import files

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

"""## Aper√ßu des donn√©es"""

df.info()
df.describe()
df.isnull().sum()
df.duplicated().sum()

"""## Analyse Exploratoire (EDA)

Distribution des ventes
"""

print(df.columns)

"""Une fois le fichier t√©l√©charg√©, nous pouvons modifier la cellule de chargement du jeu de donn√©es pour qu'elle lise le fichier directement depuis votre environnement Colab.

Interpr√©tation :
La variable Sales est asym√©trique, quelques produits r√©alisent des ventes √©lev√©es ‚Üí pr√©sence d‚Äôoutliers.

Boxplot des variables num√©riques
"""

plt.figure(figsize=(10,6))
sns.boxplot(data=df.select_dtypes(include=['float64','int64']))
plt.title("Distribution des variables num√©riques")
plt.show()

"""Corr√©lation"""

plt.figure(figsize=(10,7))
sns.heatmap(df.corr(numeric_only=True), annot=True, cmap="coolwarm")
plt.title("Matrice de corr√©lation")
plt.show()

"""Relations entre features et Sales"""

df['Sales'] = df['Price'] * df['Units_Sold']

plt.figure(figsize=(7,5))
sns.scatterplot(x="Price", y="Sales", data=df)
plt.title("Price vs Sales")
plt.show()

"""Sales par Product Category"""

plt.figure(figsize=(10,5))
sns.boxplot(x="Product_Category", y="Sales", data=df)
plt.title("Sales par cat√©gorie")
plt.xticks(rotation=45)
plt.show()

"""## Pr√©traitement"""

df.drop_duplicates(inplace=True)
df.fillna(df.median(numeric_only=True), inplace=True)

target = "Sales"
X = df.drop(columns=[target])
y = df[target]

num_cols = X.select_dtypes(include=['int64', 'float64']).columns
cat_cols = X.select_dtypes(include=['object']).columns

preprocessor = ColumnTransformer([
    ("num", StandardScaler(), num_cols),
    ("cat", OneHotEncoder(handle_unknown="ignore"), cat_cols)
])

"""## Mod√©lisation Machine Learning"""

models = {
    "Linear Regression": LinearRegression(),
    "Random Forest": RandomForestRegressor(n_estimators=200),
    "XGBoost": XGBRegressor(n_estimators=300, learning_rate=0.05)
}

results = {}

for name, model in models.items():
    pipe = Pipeline([
        ("preprocessing", preprocessor),
        ("model", model)
    ])

    cv_score = cross_val_score(pipe, X, y, cv=5, scoring="neg_root_mean_squared_error")
    results[name] = abs(cv_score.mean())

results

"""## Entra√Ænement du meilleur mod√®le"""

best_model = Pipeline([
    ("preprocessing", preprocessor),
    ("model", XGBRegressor(n_estimators=300, learning_rate=0.05))
])

best_model.fit(X, y)

y_pred = best_model.predict(X)

rmse = np.sqrt(mean_squared_error(y, y_pred))
r2 = r2_score(y, y_pred)

rmse, r2